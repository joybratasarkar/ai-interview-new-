# apps/ai_interview/tasks/audio.py

from apps.ai_interview.celery_app import celery_app
from apps.ai_interview.config import REDIS_URL

import numpy as np
import torch
import time
import json
import base64
import redis
import asyncio
from collections import deque
import redis.asyncio as aioredis
from datetime import datetime

# Load Silero VAD model once
model, utils = torch.hub.load(
    repo_or_dir='snakers4/silero-vad',
    model='silero_vad',
    trust_repo=True
)
(get_speech_ts, save_audio, read_audio, VADIterator, collect_chunks) = utils

# Constants for 2s pause detection
SAMPLE_RATE       = 16000
CHUNK_SIZE        = 512
SILENCE_THRESHOLD = 0.5
NOISE_THRESHOLD   = -40
PAUSE_SECONDS     = 2.0   # exactly 2s pause
DEBOUNCE_DELAY    = 1.5
MIN_SPEECH_TIME   = 0.5
MAX_BUFFER_SAMPLES= SAMPLE_RATE * 10  # ~10s audio
CHANNEL           = "interview_updates"

# Redis sync client
dis = redis.Redis.from_url(REDIS_URL, decode_responses=True)

# In-memory state per room
stream_states = {}  # room_id -> StreamState
paused_rooms   = {}  # room_id -> datetime of confirmed pause


class StreamState:
    def __init__(self):
        self.buffer = deque()            # float32 samples
        self.first_speech_time = None    # time speech began
        self.last_speech_time = time.time()  # last detected speech

    def rms_dbfs(self, chunk: np.ndarray) -> float:
        rms = np.sqrt(np.mean(chunk**2))
        return -100.0 if rms == 0 else 20 * np.log10(rms)

    def process_chunk(self, chunk: np.ndarray) -> bool:
        """
        Return True if a validated pause is detected:
          - user has spoken at least MIN_SPEECH_TIME
          - followed by PAUSE_SECONDS of silence
        """
        dbfs = self.rms_dbfs(chunk)
        prob = model(torch.from_numpy(chunk).float(), SAMPLE_RATE).item()
        is_speech = (prob > SILENCE_THRESHOLD) and (dbfs > NOISE_THRESHOLD)

        now = time.time()
        if is_speech:
            if self.first_speech_time is None:
                self.first_speech_time = now
            self.last_speech_time = now
            return False

        # if not enough speech before, ignore
        if (self.first_speech_time is None) or (now - self.first_speech_time < MIN_SPEECH_TIME):
            return False

        # return True if silence >= PAUSE_SECONDS
        return (now - self.last_speech_time) >= PAUSE_SECONDS


@celery_app.task(name="apps.ai_interview.tasks.audio.process_audio")
def process_audio(payload):
    # Parse JSON payload
    if isinstance(payload, str):
        try:
            payload = json.loads(payload)
        except json.JSONDecodeError:
            return

    room_id = payload.get("room_id", "default")
    audio_b64 = payload.get("text")
    if not audio_b64:
        return

    # Skip if this turn already ended\    
    if dis.get(f"turn-ended:{room_id}") == "1":
        return

    # Decode the base64 audio chunk
    try:
        raw = base64.b64decode(audio_b64)
        samples = np.frombuffer(raw, dtype=np.float32)
    except Exception:
        return

    # Get or create the StreamState
    st = stream_states.setdefault(room_id, StreamState())

    # Append samples and cap buffer size
    st.buffer.extend(samples.tolist())
    while len(st.buffer) > MAX_BUFFER_SAMPLES:
        st.buffer.popleft()

    # Process in fixed CHUNK_SIZE windows
    while len(st.buffer) >= CHUNK_SIZE:
        window = np.array([st.buffer.popleft() for _ in range(CHUNK_SIZE)], dtype=np.float32)

        if st.process_chunk(window):
            # Tentative pause detected
            time.sleep(DEBOUNCE_DELAY)
            # Re-check with a silent window
            silent = st.process_chunk(np.zeros(CHUNK_SIZE, dtype=np.float32))
            if silent:
                _submit_and_cleanup(room_id)
                return
            else:
                # user spoke during debounce; abort
                break
        # else: loop continues


def _submit_and_cleanup(room_id: str):
    # Clear in-memory state
    stream_states.pop(room_id, None)
    paused_rooms[room_id] = datetime.utcnow()

    # Mark turn-ended in Redis (TTL 5m)
    dis.setex(f"turn-ended:{room_id}", 300, "1")

    # Publish pause event
    pub = redis.Redis.from_url(REDIS_URL)
    msg = {"room_id": room_id, "task_type": "audio", "result": True}
    pub.publish(CHANNEL, json.dumps(msg, ensure_ascii=False))

    # Async cleanup of Redis keys
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(_cleanup_room(room_id))
    except RuntimeError:
        asyncio.run(_cleanup_room(room_id))


async def _cleanup_room(room_id: str):
    r = aioredis.from_url(REDIS_URL, decode_responses=True)
    await r.delete(f"stream:{room_id}", f"turn-ended:{room_id}")
    await r.close()
    paused_rooms.pop(room_id, None)
